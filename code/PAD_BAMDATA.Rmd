---
title: "PAD_BAMDATA"
author: "Merritt Harlan"
date: "2/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Functions

```{r Functions}
###Run BAM for all rivers
library(bamr)

### Functions --------

#Calculate dA
#Calculate area
#' Calculate partial cross-section area from DAWG-formatted width and height matrices
#' @param w Matrix of widths
#' @param h Matrix of heights(FROM MARK)
calcdA_mat <- function(w, h) {
  stopifnot(all(dim(w) == dim(h)))
  dA <- w
  for (i in 1:nrow(dA)) {
    dA[i, ] <- calcdA_vec(w[i, ], h[i, ])
  }
  dA
}


#' Calculate partial cross-section area from width and height vectors (time series)
#' @param w vector of widths
#' @param h vector of heights(FROM MARK)
calcdA_vec <- function(w, h) {
  words <- order(w)
  warr <- w[words]
  harr <- h[words]
  delh <- c(0, diff(harr))
  delA <- cumsum(warr * delh)
  dA <- 1:length(w)
  dA[words] <- delA
  dA
}

#Calculate slope
#' Calculate slope based on height and along-river distance
#' @param xvec vector of x (along-stream) distances, measured from
#' upstream-most cross-section
#' @param hmat Matrix (space-down, time-across) of stream heights above
#'arbitrary datum.(FROM MARK)
calcslope <- function(xvec, hmat) {
  dH <- apply(hmat, 2, function(x) c(NA, -diff(x)))
  dX_vec <- c(NA, diff(xvec))
  dX <- matrix(dX_vec, ncol = ncol(hmat), nrow = nrow(hmat),
               byrow = FALSE)
  out <- dH / dX
}


#Vector of distances between pt coordinates
calc_xvec <- function(pt_coords_sp, cl){
  coords = cl@lines[[1]]@Lines[[1]]@coords
  csum = cumsum(pointDistance(coords[1:(nrow(coords)-1),], coords[2:nrow(coords),], lonlat = FALSE))
  dist_mat = pointDistance(pt_coords_sp, data.frame(cl@lines[[1]]@Lines[[1]]@coords))
  xvec = csum[apply(dist_mat, 1, FUN = which.min)]
  return(xvec)
}

PAD_bamdata <- function(WSE_all, WSE_Q, Q, bamdata, xvec, rivname){
  #Calculate dA
  calcdA_mat <- function(w, h) {
    stopifnot(all(dim(w) == dim(h)))
    dA <- w
    for (i in 1:nrow(dA)) {
      dA[i, ] <- calcdA_vec(w[i, ], h[i, ])
    }
    dA
  }
  calcdA_vec <- function(w, h) {
    words <- order(w)
    warr <- w[words]
    harr <- h[words]
    delh <- c(0, diff(harr))
    delA <- cumsum(warr * delh)
    dA <- 1:length(w)
    dA[words] <- delA
    dA
  }
  
  #Calculate slope
  calcslope <- function(xvec, hmat) {
    dH <- apply(hmat, 2, function(x) c(NA, -diff(x)))
    dX_vec <- c(NA, diff(xvec))
    dX <- matrix(dX_vec, ncol = ncol(hmat), nrow = nrow(hmat),
                 byrow = FALSE)
    out <- dH / dX
  }
  if(rivname == "Rochers"){
    WSE_all$date = as.Date(as.character(WSE_all$new_time), format = "%m/%d/%Y")
  }else if(rivname == "Fletcher"){
    WSE_all$date = as.Date(as.character(WSE_all$new_time), format = "%m/%d/%Y")
  }else{
    WSE_all$date = as.Date(WSE_all$new_time)
  }
  
  WSE_all = aggregate(.~date, data = WSE_all, FUN = mean)
  height = t(WSE_all[, 4:ncol(WSE_all)])
  width = matrix(bamdata$Wobs[1,1], nrow = (ncol(WSE_all)-3), ncol = nrow(WSE_all))
  dA = calcdA_mat(width, height)
  slope = calcslope(xvec = xvec, hmat = height)
  slope = rbind(colMeans(slope, na.rm = TRUE), slope)
  slope = slope[c(1, 3:nrow(slope)),]
  slope[slope<=0] = min(slope[slope>0], na.rm = TRUE)
  slope[is.na(slope)] = mean(slope, na.rm = TRUE)
  data = bam_data(w = width, s = slope, dA = dA, Qhat = exp(bamdata$logQ_hat))
  return(data)
}

```

## Athabasca

You can also embed plots, for example:

```{r Athabasca, echo=FALSE}
library(dplyr)
library(bamr)
library(rgdal)
library(sp)
library(raster)

#load WSE
Athabasca_WSE <- read.csv("../input/PAD/Raw/Athabasca/WSE/Athabasca_WSE_PPP_corr.csv")
Athabasca_WSE <- Athabasca_WSE %>%
  mutate(day = as.Date(new_time, format="%Y-%m-%d"))
Athabasca_WSE_daily <- aggregate(. ~day, data = Athabasca_WSE, mean, na.rm = TRUE)[,c(4:ncol(Athabasca_WSE))]

#load Q
PAD_2018_ADCP <- read.csv("../input/PAD/Raw/PAD_2018_ADCP.csv")
Athabasca_qobs_df <- PAD_2018_ADCP[startsWith(as.character(PAD_2018_ADCP$Location),"ATH"),]
Athabasca_qobs_df <- Athabasca_qobs_df %>%
  mutate(day = as.Date(new_date, format="%Y-%m-%d"))
Athabasca_corr_Q <- Athabasca_qobs_df[Athabasca_qobs_df$Q>600,]

Athabasca_corr_Q <- Athabasca_corr_Q %>%
  mutate(day = as.Date(new_date, format="%Y-%m-%d"))

#load cl and PT coords
wd = getwd()
setwd("../input/PAD/Centerline")
Athabasca_cl <-readOGR(dsn = ".", layer = "Athabasca_cl_UTM")
setwd(wd)

Athabasca_PT_coords <- read.csv("../input/PAD/PT_coords/Athabasca_PT_coords.csv")
Athabasca_PT_coords_sp <-SpatialPoints(Athabasca_PT_coords[,4:5], 
                                       proj4string = crs('+proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0' ))

#calculate the distance between pts
Athabasca_xvec <- calc_xvec(Athabasca_PT_coords_sp, Athabasca_cl)

#find overlapping ADCP and PT times
Athabasca_closest_time <- vector(length = length(Athabasca_corr_Q$new_date))
for(i in 1:length(Athabasca_corr_Q$new_date)){
  Athabasca_closest_time[i] = which.min(abs(as.POSIXct(Athabasca_WSE$new_time, tz = "MST") - 
                                              as.POSIXct(Athabasca_corr_Q$new_date[i], tz = "MST")))
}

Athabasca_WSE_corrQ <- Athabasca_WSE[c(Athabasca_closest_time[order(Athabasca_closest_time)]),c(3:7)]

#Calculate slope
Athabasca_slope <- calcslope(sort(Athabasca_xvec), hmat = t(Athabasca_WSE_corrQ[, order(Athabasca_xvec)]))
Athabasca_slope[1,] <- colMeans(Athabasca_slope, na.rm = TRUE)

#Get width from ADCP data
Athabasca_width = matrix(rep(Athabasca_corr_Q$Width, nrow(Athabasca_slope)), nrow = nrow(Athabasca_slope), byrow= TRUE)

#Calculate dA
Athabasca_dA = calcdA_mat(w = Athabasca_width, h = t(Athabasca_WSE_corrQ))

#Split into two reaches
Athabasca_bamdata = bam_data(w = Athabasca_width, s = Athabasca_slope, dA = Athabasca_dA, Qhat = Athabasca_corr_Q$Q)

Athabasca_data$dAobs[,1] = rowMeans(Athabasca_data$dAobs)
Athabasca_rch1_data = bam_data(w = Athabasca_data$Wobs[c(1,2),43:46], Athabasca_data$Sobs[c(1,2),43:46],
                              dA = Athabasca_data$dAobs[c(1,2),43:46], 
                              Qhat = Athabasca_corr_Q[Athabasca_corr_Q$coords.x2<=6475948,"Q"])

#Full time series
saveRDS(Athabasca_bamdata, file = "../input/PAD/BAMdata.rds")
```

## Coupe

You can also embed plots, for example:

```{r Coupe, echo=FALSE}
library(dplyr)
library(bamr)
library(rgdal)
library(sp)
library(raster)

#load WSE
Coupe_WSE <- read.csv("../input/PAD/Raw/Coupe/WSE/Coupe_WSE_PPP_corr.csv")
Coupe_WSE <- Coupe_WSE %>%
  mutate(day = as.Date(new_time, format="%Y-%m-%d"))
Coupe_WSE_daily <- aggregate(. ~day, data = Coupe_WSE, mean, na.rm = TRUE)[,c(4:ncol(Coupe_WSE))]

#load Q
PAD_2018_ADCP <- read.csv("../input/PAD/Raw/PAD_2018_ADCP.csv")
Coupe_qobs_df <- PAD_2018_ADCP[startsWith(as.character(PAD_2018_ADCP$Location),"CP"),]
Coupe_qobs_df <- Coupe_qobs_df %>%
  mutate(day = as.Date(new_date, format="%Y-%m-%d"))
Coupe_corr_Q <- Coupe_qobs_df[Coupe_qobs_df$Q>600,]

Coupe_corr_Q <- Coupe_corr_Q %>%
  mutate(day = as.Date(new_date, format="%Y-%m-%d"))

#load cl and PT coords
wd = getwd()
setwd("../input/PAD/Centerline")
Coupe_cl <-readOGR(dsn = ".", layer = "Coupe_cl_UTM")
setwd(wd)

Coupe_PT_coords <- read.csv("../input/PAD/PT_coords/Coupe_PT_coords.csv")
Coupe_PT_coords_sp <-SpatialPoints(Coupe_PT_coords[,4:5], 
                                       proj4string = crs('+proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0' ))

#calculate the distance between pts
Coupe_xvec <- calc_xvec(Coupe_PT_coords_sp, Coupe_cl)

#find overlapping ADCP and PT times
Coupe_closest_time <- vector(length = length(Coupe_corr_Q$new_date))
for(i in 1:length(Coupe_corr_Q$new_date)){
  Coupe_closest_time[i] = which.min(abs(as.POSIXct(Coupe_WSE$new_time, tz = "MST") - 
                                              as.POSIXct(Coupe_corr_Q$new_date[i], tz = "MST")))
}

Coupe_WSE_corrQ <- Coupe_WSE[c(Coupe_closest_time[order(Coupe_closest_time)]),c(3:7)]

#Calculate slope
Coupe_slope <- calcslope(sort(Coupe_xvec), hmat = t(Coupe_WSE_corrQ[, order(Coupe_xvec)]))
Coupe_slope[1,] <- colMeans(Coupe_slope, na.rm = TRUE)

#Get width from ADCP data
Coupe_width = matrix(rep(Coupe_corr_Q$Width, nrow(Coupe_slope)), nrow = nrow(Coupe_slope), byrow= TRUE)

#Calculate dA
Coupe_dA = calcdA_mat(w = Coupe_width, h = t(Coupe_WSE_corrQ))

#Save as bamdata
Coupe_bamdata = bam_data(w = Coupe_width, s = Coupe_slope, dA = Coupe_dA, Qhat = Coupe_corr_Q$Q)

saveRDS(Coupe_bamdata, file = "../input/PAD/BAMdata.rds")

bamr::bam_plot(Coupe_bamdata)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
